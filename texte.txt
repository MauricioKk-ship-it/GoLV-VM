
 Tu voie mon server fais pour moi un frontend complet en intégrant nos communauté de notre entreprise gopu.inc Voilà nos communautés sur threads https://www.threads.com/@mangitukamauricio/post/DSVcsKfDF3k?xmt=AQF0Fd8JYRTlbOX92hGrswpbCkIdjIOmlJco6fB1x0OK7NzDj89Yo4dL7lBBBN8imNi29qen&slof=1 Discord https://discord.gg/qWx5DszrC sur linkedin c’est ceoseshell est sur github c’est  https://github.com/gopu-inc/GoLV-VM
Mon lien Twitch c’est twitch.tv/gopuinc
Voilà le server doit avoir de fenêtre est de gestion plus pour téléphone mobile portable est plus utilisé de svg pour le logo est autre voilà 

Il doit être connecté via cette url https://golv.onrender.com


#!/usr/bin/env python3
"""
GoLV Server - API de Machines Virtuelles avec Cloudinary
API seulement - avec gestion de fichiers Cloudinary et exécution de commandes
"""

import os
import sys
import json
import uuid
import time
import hashlib
import secrets
import asyncio
import re
import random
import subprocess
import shutil
import tempfile
from datetime import datetime, timedelta
from typing import Optional, Dict, Any, List
from pathlib import Path
import html
import ssl
import base64
import io

# === IMPORTS ===
try:
    from fastapi import FastAPI, HTTPException, Depends, status, Request, Form, Query, UploadFile, File, Body
    from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
    from fastapi.middleware.cors import CORSMiddleware
    from fastapi.responses import HTMLResponse, RedirectResponse, JSONResponse, StreamingResponse, FileResponse
    from pydantic import BaseModel, Field, validator
    import jwt
    import bcrypt
    import asyncpg
    import uvicorn
    import humanize
    from contextlib import asynccontextmanager
    import aiofiles
    import cloudinary
    import cloudinary.uploader
    import cloudinary.api
    from cloudinary.utils import cloudinary_url
except ImportError as e:
    print(f"Erreur import: {e}")
    print("pip install fastapi uvicorn asyncpg pyjwt bcrypt aiofiles cloudinary")
    sys.exit(1)

# === CONFIGURATION FTP ===
class FTPConfig:
    # Configuration DriveHQ
    DRIVEHQ_HOST = "ftp.drivehq.com"
    DRIVEHQ_USERNAME = os.environ.get("DRIVEHQ_USERNAME", "Ceose Shell")
    DRIVEHQ_PASSWORD = os.environ.get("DRIVEHQ_PASSWORD", "Tukss1231@")
    DRIVEHQ_PORT = 21
    
    # Répertoires
    FTP_VM_STORAGE = "/vm_storage"
    FTP_BACKUP_DIR = "/backups"
    FTP_EXPORTS_DIR = "/exports"

# === CONFIGURATION CLOUDINARY ===
cloudinary.config(
    cloud_name="ddwc5zeyc",
    api_key="523354246567532",
    api_secret="dT1Qm5jMveah3ZhcAS2UuW4NYKs",
    secure=True
)

# === CONFIGURATION ===
class Config:
    APP_NAME = "GoLV VM Marketplace API"
    APP_VERSION = "2.0.0"
    HOST = "0.0.0.0"
    PORT = int(os.environ.get("PORT", 8000))
    
    # PostgreSQL Render.com - AVEC SSL
    DATABASE_URL = os.getenv("DATABASE_URL", 
        "postgresql://volve_user:odM5spc4DLMdEPJww834aDNE7c49J9bG@dpg-d4vpeu24d50c7385s840-a.oregon-postgres.render.com/volve?sslmode=require")
    
    SECRET_KEY = os.environ.get("SECRET_KEY", "change_this_secret_key_in_production_12345")
    ALGORITHM = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES = 10080
    
    # Cloudinary
    CLOUDINARY_CLOUD_NAME = "ddwc5zeyc"
    CLOUDINARY_API_KEY = "523354246567532"
    CLOUDINARY_API_SECRET = "dT1Qm5jMveah3ZhcAS2UuW4NYKs"
    
    # Types de VMs avec versions
    VM_TYPES = {
        "ubuntu": {
            "name": "Ubuntu Server",
            "versions": ["22.04 LTS", "20.04 LTS", "18.04 LTS", "24.04 LTS"],
            "description": "Distribution Linux populaire pour serveurs",
            "default_tags": ["linux", "server", "debian", "cloud"]
        },
        "debian": {
            "name": "Debian",
            "versions": ["12 Bookworm", "11 Bullseye", "10 Buster"],
            "description": "Distribution stable et fiable",
            "default_tags": ["linux", "stable", "minimal", "secure"]
        },
        "python-dev": {
            "name": "Python Dev",
            "versions": ["3.11", "3.10", "3.9", "3.8"],
            "description": "Environnement de développement Python",
            "default_tags": ["python", "development", "programming", "api"]
        },
        "nodejs": {
            "name": "Node.js",
            "versions": ["20 LTS", "18 LTS", "16 LTS"],
            "description": "Environnement Node.js avec npm",
            "default_tags": ["javascript", "node", "web", "backend"]
        },
        "docker-host": {
            "name": "Docker Host",
            "versions": ["Latest", "Stable", "Edge"],
            "description": "Machine hôte Docker avec outils",
            "default_tags": ["docker", "containers", "devops", "ci-cd"]
        },
        "wordpress": {
            "name": "WordPress",
            "versions": ["6.4", "6.3", "6.2"],
            "description": "Stack WordPress complète",
            "default_tags": ["wordpress", "cms", "blog", "website"]
        }
    }
    
    # Limites
    MAX_VMS_PER_USER = 20
    MAX_PUBLICATIONS = 50
    MAX_COMMENTS_PER_VM = 100
    MAX_FILE_SIZE_MB = 100  # Taille max des fichiers uploadés sur Cloudinary
    
    # Répertoires
    VM_STORAGE = Path("/tmp/golv_vms")
    EXPORT_STORAGE = Path("/tmp/golv_exports")
    
    # Sécurité commandes
    ALLOWED_COMMANDS = [
        "pwd", "ls", "echo", "cat", "python3", "python",
        "pip", "npm", "node", "git", "curl", "wget",
        "mkdir", "rmdir", "touch", "find", "grep", "df",
        "du", "date", "whoami", "uname", "hostname"
    ]
    BANNED_COMMANDS = ["rm -rf", "shutdown", "reboot", "dd", "mkfs", ":(){"]

# === MODÈLES ===
class UserCreate(BaseModel):
    username: str = Field(..., min_length=3, max_length=50)
    password: str = Field(..., min_length=6)

class UserLogin(BaseModel):
    username: str
    password: str

class VMCreate(BaseModel):
    name: str
    vm_type: str
    version: str
    is_public: bool = False
    description: Optional[str] = None
    tags: Optional[List[str]] = []

class VMUpdate(BaseModel):
    name: Optional[str] = None
    description: Optional[str] = None
    is_public: Optional[bool] = None
    tags: Optional[List[str]] = None

class FileUpload(BaseModel):
    filename: str
    content_type: str

class CodeFileCreate(BaseModel):
    vm_id: str
    file_path: str
    content: str
    language: Optional[str] = None

class CodeFileUpdate(BaseModel):
    content: str

class PublicationCreate(BaseModel):
    vm_id: str
    title: str
    description: str
    price: Optional[float] = None
    is_free: bool = True

class CommentCreate(BaseModel):
    vm_id: str
    content: str
    rating: int = Field(5, ge=1, le=5)

class Token(BaseModel):
    access_token: str
    token_type: str
    user_id: int
    username: str
    role: str

class TokenData(BaseModel):
    username: Optional[str] = None
    user_id: Optional[int] = None
    role: Optional[str] = None

# === NOUVEAU MODÈLE POUR COMMANDES ===
class VMCommand(BaseModel):
    command: str
    timeout: int = Field(30, ge=1, le=300)
    user: str = Field("root")
    working_dir: Optional[str] = None
    async_execution: bool = Field(False)

# === DATABASE ===
class Database:
    pool = None
    
    @classmethod
    async def connect(cls):
        """Connexion PostgreSQL Render.com - AVEC SSL"""
        if cls.pool:
            return cls.pool
        
        print("Connexion à PostgreSQL Render.com...")
        
        try:
            # Nettoyer URL
            db_url = Config.DATABASE_URL
            if db_url.startswith("postgres://"):
                db_url = db_url.replace("postgres://", "postgresql://", 1)
            
            # S'assurer que SSL est requis
            if "?sslmode=" not in db_url:
                db_url += "?sslmode=require"
            
            # Connexion AVEC SSL (Render.com nécessite SSL)
            cls.pool = await asyncpg.create_pool(
                dsn=db_url,
                ssl=True,
                min_size=1,
                max_size=10,
                command_timeout=60
            )
            
            # Test connexion
            async with cls.pool.acquire() as conn:
                version = await conn.fetchval("SELECT version()")
                print(f"PostgreSQL connecté (Render.com avec SSL): {version.split(',')[0]}")
            
            # Créer tables
            await cls._create_tables()
            
            return cls.pool
            
        except Exception as e:
            print(f"ERREUR connexion DB: {type(e).__name__}: {e}")
            raise HTTPException(
                status_code=500,
                detail=f"Database connection failed: {str(e)[:100]}"
            )
    
    @classmethod
    async def _create_tables(cls):
        """Créer toutes les tables"""
        if not cls.pool:
            return
            
        try:
            async with cls.pool.acquire() as conn:
                # Table utilisateurs
                await conn.execute("""
                    CREATE TABLE IF NOT EXISTS users (
                        id SERIAL PRIMARY KEY,
                        username VARCHAR(50) UNIQUE NOT NULL,
                        password_hash TEXT NOT NULL,
                        api_key VARCHAR(100) UNIQUE,
                        avatar_url TEXT,
                        bio TEXT,
                        role VARCHAR(20) DEFAULT 'user',
                        reputation INTEGER DEFAULT 0,
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        last_login TIMESTAMP,
                        stats JSONB DEFAULT '{"vms_created": 0, "downloads_given": 0, "publications": 0}'
                    )
                """)
                
                # Table VMs
                await conn.execute("""
                    CREATE TABLE IF NOT EXISTS vms (
                        id VARCHAR(50) PRIMARY KEY,
                        name VARCHAR(100) NOT NULL,
                        description TEXT,
                        vm_type VARCHAR(50) NOT NULL,
                        version VARCHAR(20) NOT NULL,
                        owner_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
                        status VARCHAR(20) DEFAULT 'stopped',
                        is_public BOOLEAN DEFAULT FALSE,
                        is_published BOOLEAN DEFAULT FALSE,
                        downloads_count INTEGER DEFAULT 0,
                        views_count INTEGER DEFAULT 0,
                        average_rating DECIMAL(3,2) DEFAULT 0,
                        total_ratings INTEGER DEFAULT 0,
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        last_download TIMESTAMP,
                        config JSONB DEFAULT '{}',
                        tags JSONB DEFAULT '[]',
                        metadata JSONB DEFAULT '{}'
                    )
                """)
                
                # Table fichiers de code (liés aux VMs)
                await conn.execute("""
                    CREATE TABLE IF NOT EXISTS code_files (
                        id SERIAL PRIMARY KEY,
                        vm_id VARCHAR(50) REFERENCES vms(id) ON DELETE CASCADE,
                        user_id INTEGER REFERENCES users(id),
                        file_path VARCHAR(500) NOT NULL,
                        file_name VARCHAR(200) NOT NULL,
                        file_size INTEGER,
                        content_type VARCHAR(100),
                        cloudinary_url TEXT,
                        cloudinary_public_id VARCHAR(200),
                        language VARCHAR(50),
                        content TEXT,
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                    )
                """)
                
                # Table publications (boutique)
                await conn.execute("""
                    CREATE TABLE IF NOT EXISTS publications (
                        id SERIAL PRIMARY KEY,
                        vm_id VARCHAR(50) REFERENCES vms(id) ON DELETE CASCADE,
                        publisher_id INTEGER REFERENCES users(id),
                        title VARCHAR(200) NOT NULL,
                        description TEXT,
                        price DECIMAL(10,2),
                        is_free BOOLEAN DEFAULT TRUE,
                        featured_image TEXT,
                        featured_svg TEXT,
                        downloads_count INTEGER DEFAULT 0,
                        views_count INTEGER DEFAULT 0,
                        is_featured BOOLEAN DEFAULT FALSE,
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                    )
                """)
                
                # Table commentaires et ratings
                await conn.execute("""
                    CREATE TABLE IF NOT EXISTS comments (
                        id SERIAL PRIMARY KEY,
                        vm_id VARCHAR(50) REFERENCES vms(id) ON DELETE CASCADE,
                        user_id INTEGER REFERENCES users(id),
                        content TEXT NOT NULL,
                        rating INTEGER CHECK (rating >= 1 AND rating <= 5),
                        likes_count INTEGER DEFAULT 0,
                        is_edited BOOLEAN DEFAULT FALSE,
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                    )
                """)
                
                # Table téléchargements
                await conn.execute("""
                    CREATE TABLE IF NOT EXISTS downloads (
                        id SERIAL PRIMARY KEY,
                        vm_id VARCHAR(50) REFERENCES vms(id) ON DELETE CASCADE,
                        user_id INTEGER REFERENCES users(id),
                        downloaded_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        version VARCHAR(20),
                        ip_address VARCHAR(45)
                    )
                """)
                
                # Table commandes exécutées
                await conn.execute("""
                    CREATE TABLE IF NOT EXISTS vm_commands (
                        id SERIAL PRIMARY KEY,
                        vm_id VARCHAR(50) REFERENCES vms(id) ON DELETE CASCADE,
                        user_id INTEGER REFERENCES users(id),
                        command TEXT NOT NULL,
                        return_code INTEGER,
                        stdout TEXT,
                        stderr TEXT,
                        executed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        duration_ms INTEGER,
                        status VARCHAR(20) DEFAULT 'completed'
                    )
                """)
                
                # Table likes de commentaires
                await conn.execute("""
                    CREATE TABLE IF NOT EXISTS comment_likes (
                        comment_id INTEGER REFERENCES comments(id) ON DELETE CASCADE,
                        user_id INTEGER REFERENCES users(id),
                        liked_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        PRIMARY KEY (comment_id, user_id)
                    )
                """)
                
                # Table vues de VMs
                await conn.execute("""
                    CREATE TABLE IF NOT EXISTS vm_views (
                        vm_id VARCHAR(50) REFERENCES vms(id) ON DELETE CASCADE,
                        user_id INTEGER REFERENCES users(id),
                        viewed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        PRIMARY KEY (vm_id, user_id)
                    )
                """)
                
                # Table favoris
                await conn.execute("""
                    CREATE TABLE IF NOT EXISTS favorites (
                        vm_id VARCHAR(50) REFERENCES vms(id) ON DELETE CASCADE,
                        user_id INTEGER REFERENCES users(id),
                        favorited_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        PRIMARY KEY (vm_id, user_id)
                    )
                """)
                
                # Index pour performances
                await conn.execute("""
                    CREATE INDEX IF NOT EXISTS idx_vms_owner ON vms(owner_id);
                    CREATE INDEX IF NOT EXISTS idx_vms_public ON vms(is_public) WHERE is_public = TRUE;
                    CREATE INDEX IF NOT EXISTS idx_vms_published ON vms(is_published) WHERE is_published = TRUE;
                    CREATE INDEX IF NOT EXISTS idx_vms_downloads ON vms(downloads_count DESC);
                    CREATE INDEX IF NOT EXISTS idx_vms_rating ON vms(average_rating DESC);
                    CREATE INDEX IF NOT EXISTS idx_code_files_vm ON code_files(vm_id);
                    CREATE INDEX IF NOT EXISTS idx_comments_vm ON comments(vm_id);
                    CREATE INDEX IF NOT EXISTS idx_publications_featured ON publications(is_featured) WHERE is_featured = TRUE;
                    CREATE INDEX IF NOT EXISTS idx_downloads_vm ON downloads(vm_id);
                    CREATE INDEX IF NOT EXISTS idx_vm_commands_vm ON vm_commands(vm_id);
                """)
                
                # Créer admin si inexistant
                admin_exists = await conn.fetchval(
                    "SELECT COUNT(*) FROM users WHERE username = 'admin'"
                )
                
                if not admin_exists:
                    password_hash = bcrypt.hashpw(b"admin123", bcrypt.gensalt()).decode()
                    api_key = f"glv_admin_{secrets.token_urlsafe(16)}"
                    
                    await conn.execute("""
                        INSERT INTO users (username, password_hash, api_key, role, bio)
                        VALUES ($1, $2, $3, 'admin', $4)
                    """, "admin", password_hash, api_key, "Administrateur GoLV Marketplace")
                    
                    print("Admin créé: admin / admin123")
                
                print("Tables créées/vérifiées")
                
        except Exception as e:
            print(f"Erreur création tables: {e}")

# === SÉCURITÉ ===
class SecurityUtils:
    @staticmethod
    def hash_password(password: str) -> str:
        return bcrypt.hashpw(password.encode(), bcrypt.gensalt()).decode()
    
    @staticmethod
    def verify_password(password: str, hashed: str) -> bool:
        try:
            return bcrypt.checkpw(password.encode(), hashed.encode())
        except:
            return False
    
    @staticmethod
    def create_jwt_token(username: str, user_id: int, role: str = "user") -> str:
        payload = {
            "sub": username,
            "user_id": user_id,
            "role": role,
            "exp": datetime.utcnow() + timedelta(minutes=Config.ACCESS_TOKEN_EXPIRE_MINUTES)
        }
        return jwt.encode(payload, Config.SECRET_KEY, algorithm=Config.ALGORITHM)
    
    @staticmethod
    def verify_jwt_token(token: str) -> Dict:
        try:
            payload = jwt.decode(token, Config.SECRET_KEY, algorithms=[Config.ALGORITHM])
            return payload
        except jwt.ExpiredSignatureError:
            raise HTTPException(status_code=401, detail="Token expiré")
        except jwt.InvalidTokenError:
            raise HTTPException(status_code=401, detail="Token invalide")
    
    @staticmethod
    def validate_command(command: str) -> bool:
        """Valider une commande pour la sécurité"""
        # Vérifier les commandes bannies
        for banned in Config.BANNED_COMMANDS:
            if banned in command.lower():
                return False
        
        # Vérifier les commandes autorisées (premier mot)
        first_word = command.split()[0] if command.split() else ""
        
        # Autoriser les commandes Python et echo même si pas dans la liste
        if first_word.startswith("python") or first_word == "echo":
            return True
        
        # Vérifier dans la liste des commandes autorisées
        if first_word not in Config.ALLOWED_COMMANDS:
            return False
        
        return True

# === GESTIONNAIRE CLOUDINARY ===
class CloudinaryManager:
    """Gestionnaire pour Cloudinary"""
    
    @staticmethod
    async def upload_file(file: UploadFile, folder: str = "golv_vms") -> Dict[str, Any]:
        """Uploader un fichier sur Cloudinary"""
        try:
            # Lire le fichier
            content = await file.read()
            file_size = len(content)
            
            # Vérifier la taille
            if file_size > Config.MAX_FILE_SIZE_MB * 1024 * 1024:
                raise HTTPException(
                    status_code=400,
                    detail=f"Fichier trop volumineux. Max: {Config.MAX_FILE_SIZE_MB}MB"
                )
            
            # Créer un fichier temporaire
            with tempfile.NamedTemporaryFile(delete=False, suffix=os.path.splitext(file.filename)[1]) as tmp:
                tmp.write(content)
                tmp_path = tmp.name
            
            try:
                # Upload sur Cloudinary
                upload_result = cloudinary.uploader.upload(
                    tmp_path,
                    folder=folder,
                    resource_type="auto",
                    use_filename=True,
                    unique_filename=True,
                    overwrite=False
                )
                
                # Nettoyer le fichier temporaire
                os.unlink(tmp_path)
                
                return {
                    "success": True,
                    "public_id": upload_result.get("public_id"),
                    "secure_url": upload_result.get("secure_url"),
                    "url": upload_result.get("url"),
                    "format": upload_result.get("format"),
                    "resource_type": upload_result.get("resource_type"),
                    "bytes": upload_result.get("bytes"),
                    "width": upload_result.get("width"),
                    "height": upload_result.get("height")
                }
                
            except Exception as e:
                if os.path.exists(tmp_path):
                    os.unlink(tmp_path)
                raise e
                
        except HTTPException:
            raise
        except Exception as e:
            print(f"Erreur upload Cloudinary: {e}")
            raise HTTPException(status_code=500, detail=f"Erreur upload fichier: {str(e)}")
    
    @staticmethod
    async def upload_code_content(content: str, filename: str, folder: str = "golv_code") -> Dict[str, Any]:
        """Uploader du contenu de code sur Cloudinary"""
        try:
            # Créer un fichier temporaire avec le contenu
            with tempfile.NamedTemporaryFile(mode='w', delete=False, suffix=".txt", encoding='utf-8') as tmp:
                tmp.write(content)
                tmp_path = tmp.name
            
            try:
                # Upload sur Cloudinary
                upload_result = cloudinary.uploader.upload(
                    tmp_path,
                    folder=f"{folder}/{filename}",
                    resource_type="raw",
                    use_filename=True,
                    unique_filename=False,
                    overwrite=True,
                    type="upload"
                )
                
                # Nettoyer le fichier temporaire
                os.unlink(tmp_path)
                
                return {
                    "success": True,
                    "public_id": upload_result.get("public_id"),
                    "secure_url": upload_result.get("secure_url"),
                    "url": upload_result.get("url")
                }
                
            except Exception as e:
                if os.path.exists(tmp_path):
                    os.unlink(tmp_path)
                raise e
                
        except Exception as e:
            print(f"Erreur upload code Cloudinary: {e}")
            raise HTTPException(status_code=500, detail=f"Erreur upload code: {str(e)}")
    
    @staticmethod
    async def delete_file(public_id: str) -> bool:
        """Supprimer un fichier de Cloudinary"""
        try:
            result = cloudinary.uploader.destroy(public_id)
            return result.get("result") == "ok"
        except Exception as e:
            print(f"Erreur suppression Cloudinary: {e}")
            return False
    
    @staticmethod
    async def generate_image_url(public_id: str, transformations: List[Dict] = None) -> str:
        """Générer une URL d'image avec transformations"""
        try:
            if transformations:
                url, options = cloudinary_url(
                    public_id,
                    transformation=transformations
                )
            else:
                url, options = cloudinary_url(public_id)
            
            return url
        except Exception as e:
            print(f"Erreur génération URL Cloudinary: {e}")
            return ""

# === VM MANAGER ===
class VMManager:
    """Gestionnaire de VMs"""
    
    def __init__(self):
        self.vm_storage = Config.VM_STORAGE
        self.export_storage = Config.EXPORT_STORAGE
        
        for storage in [self.vm_storage, self.export_storage]:
            storage.mkdir(parents=True, exist_ok=True)
        
        self.processes = {}
        self.command_history = {}
    
    async def create_vm(self, vm_id: str, vm_type: str, version: str, owner_id: int) -> Dict[str, Any]:
        """Créer une nouvelle VM"""
        vm_path = self.vm_storage / vm_id
        vm_path.mkdir(exist_ok=True)
        
        # Créer structure
        (vm_path / "root").mkdir(exist_ok=True)
        (vm_path / "config").mkdir(exist_ok=True)
        (vm_path / "data").mkdir(exist_ok=True)
        
        # Config de base
        config = {
            "id": vm_id,
            "type": vm_type,
            "version": version,
            "owner_id": owner_id,
            "created_at": datetime.now().isoformat(),
            "status": "stopped",
            "path": str(vm_path),
            "ports": {
                "ssh": random.randint(22000, 22999),
                "web": random.randint(30000, 30999)
            },
            "ip_address": f"10.0.{random.randint(1, 255)}.{random.randint(1, 255)}",
            "stats": {
                "cpu_usage": 0.0,
                "memory_usage": 0,
                "disk_usage": 0,
                "uptime_seconds": 0,
                "commands_executed": 0
            }
        }
        
        # Sauvegarder config
        config_file = vm_path / "config" / "vm.json"
        with open(config_file, "w") as f:
            json.dump(config, f, indent=2)
        
        return {
            "success": True,
            "vm_id": vm_id,
            "name": f"VM-{vm_id[:8]}",
            "config": config,
            "message": f"VM {vm_type} {version} créée avec succès"
        }
    
    async def export_vm(self, vm_id: str, export_format: str = "tar") -> Optional[Path]:
        """Exporter une VM dans un format portable"""
        vm_path = self.vm_storage / vm_id
        if not vm_path.exists():
            return None
        
        export_file = self.export_storage / f"{vm_id}.{export_format}"
        
        try:
            if export_format == "tar":
                import tarfile
                with tarfile.open(export_file, "w:gz") as tar:
                    tar.add(vm_path, arcname=vm_id)
            elif export_format == "zip":
                import zipfile
                with zipfile.ZipFile(export_file, 'w', zipfile.ZIP_DEFLATED) as zipf:
                    for root, dirs, files in os.walk(vm_path):
                        for file in files:
                            file_path = os.path.join(root, file)
                            arcname = os.path.join(vm_id, os.path.relpath(file_path, vm_path))
                            zipf.write(file_path, arcname)
            
            return export_file
        except Exception as e:
            print(f"Erreur export VM: {e}")
            return None
    
    # === NOUVELLE MÉTHODE POUR EXÉCUTER DES COMMANDES ===
    async def execute_command(self, vm_id: str, command_data: VMCommand, user_id: int) -> Dict[str, Any]:
        """Exécuter une commande dans une VM"""
        vm_path = self.vm_storage / vm_id
        
        if not vm_path.exists():
            return {
                "success": False,
                "error": f"VM {vm_id} non trouvée localement",
                "vm_id": vm_id
            }
        
        # Validation de sécurité
        if not SecurityUtils.validate_command(command_data.command):
            return {
                "success": False,
                "error": "Commande non autorisée pour des raisons de sécurité",
                "vm_id": vm_id,
                "command": command_data.command[:50] + "..." if len(command_data.command) > 50 else command_data.command
            }
        
        start_time = time.time()
        
        try:
            # Préparer le répertoire de travail
            if command_data.working_dir:
                working_dir = vm_path / "root" / command_data.working_dir.lstrip("/")
                if not working_dir.exists():
                    working_dir.mkdir(parents=True, exist_ok=True)
                cwd = str(working_dir)
            else:
                cwd = str(vm_path / "root")
            
            print(f"Exécution commande dans VM {vm_id}: {command_data.command}")
            
            # Exécuter la commande
            process = await asyncio.create_subprocess_shell(
                command_data.command,
                cwd=cwd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
                shell=True
            )
            
            try:
                stdout, stderr = await asyncio.wait_for(
                    process.communicate(),
                    timeout=command_data.timeout
                )
                
                duration_ms = int((time.time() - start_time) * 1000)
                
                result = {
                    "success": process.returncode == 0,
                    "vm_id": vm_id,
                    "command": command_data.command,
                    "return_code": process.returncode,
                    "stdout": stdout.decode('utf-8', errors='ignore').strip(),
                    "stderr": stderr.decode('utf-8', errors='ignore').strip(),
                    "executed_at": datetime.now().isoformat(),
                    "working_dir": cwd,
                    "duration_ms": duration_ms,
                    "user_id": user_id
                }
                
                # Stocker dans l'historique local
                if vm_id not in self.command_history:
                    self.command_history[vm_id] = []
                self.command_history[vm_id].append(result)
                
                return result
                
            except asyncio.TimeoutError:
                process.kill()
                return {
                    "success": False,
                    "error": f"Timeout après {command_data.timeout} secondes",
                    "vm_id": vm_id,
                    "command": command_data.command,
                    "duration_ms": int((time.time() - start_time) * 1000)
                }
                
        except Exception as e:
            return {
                "success": False,
                "error": str(e),
                "vm_id": vm_id,
                "command": command_data.command,
                "duration_ms": int((time.time() - start_time) * 1000)
            }
    
    async def get_command_history(self, vm_id: str, limit: int = 10) -> List[Dict]:
        """Récupérer l'historique des commandes d'une VM"""
        if vm_id in self.command_history:
            return self.command_history[vm_id][-limit:]
        return []
    
    async def get_vm_status(self, vm_id: str) -> Dict[str, Any]:
        """Récupérer le statut d'une VM"""
        vm_path = self.vm_storage / vm_id
        
        if not vm_path.exists():
            return {"exists": False, "status": "not_found"}
        
        # Vérifier la taille
        total_size = 0
        file_count = 0
        for root, dirs, files in os.walk(vm_path):
            for file in files:
                filepath = os.path.join(root, file)
                if os.path.exists(filepath):
                    total_size += os.path.getsize(filepath)
                    file_count += 1
        
        # Lire la config
        config_file = vm_path / "config" / "vm.json"
        config = {}
        if config_file.exists():
            with open(config_file, 'r') as f:
                config = json.load(f)
        
        return {
            "exists": True,
            "status": "running" if (vm_path / "root").exists() else "stopped",
            "path": str(vm_path),
            "size_bytes": total_size,
            "size_human": humanize.naturalsize(total_size),
            "file_count": file_count,
            "config": config,
            "last_commands": await self.get_command_history(vm_id, 5)
        }

# === GESTIONNAIRE FTP ===
import ftplib

class FTPManager:
    """Gestionnaire pour FTP DriveHQ"""
    
    def __init__(self):
        self.config = FTPConfig()
        self.connection = None
    
    def connect(self) -> ftplib.FTP:
        """Établir une connexion FTP"""
        try:
            ftp = ftplib.FTP()
            ftp.connect(self.config.DRIVEHQ_HOST, self.config.DRIVEHQ_PORT)
            ftp.login(self.config.DRIVEHQ_USERNAME, self.config.DRIVEHQ_PASSWORD)
            ftp.set_pasv(True)  # Mode passif
            self.connection = ftp
            
            # Créer les répertoires s'ils n'existent pas
            self._ensure_directories()
            
            print(f"Connecté à DriveHQ FTP: {self.config.DRIVEHQ_USERNAME}")
            return ftp
        except Exception as e:
            print(f"Erreur connexion FTP: {e}")
            raise
    
    def _ensure_directories(self):
        """Créer les répertoires nécessaires"""
        dirs = [
            self.config.FTP_VM_STORAGE,
            self.config.FTP_BACKUP_DIR,
            self.config.FTP_EXPORTS_DIR
        ]
        
        for directory in dirs:
            try:
                self.connection.mkd(directory)
                print(f"Répertoire créé: {directory}")
            except:
                pass  # Le répertoire existe déjà probablement
    
    async def upload_vm(self, vm_id: str, local_path: Path) -> bool:
        """Uploader une VM sur DriveHQ"""
        try:
            ftp = self.connect()
            
            # Créer le répertoire de la VM
            vm_remote_dir = f"{self.config.FTP_VM_STORAGE}/{vm_id}"
            try:
                ftp.mkd(vm_remote_dir)
            except:
                pass
            
            # Uploader chaque fichier
            for root, dirs, files in os.walk(local_path):
                for dir_name in dirs:
                    remote_dir = os.path.join(vm_remote_dir, 
                                            os.path.relpath(os.path.join(root, dir_name), local_path))
                    try:
                        ftp.mkd(remote_dir)
                    except:
                        pass
                
                for file_name in files:
                    local_file = os.path.join(root, file_name)
                    remote_file = os.path.join(vm_remote_dir, 
                                             os.path.relpath(local_file, local_path))
                    
                    with open(local_file, 'rb') as f:
                        ftp.storbinary(f'STOR {remote_file}', f)
            
            ftp.quit()
            print(f"VM {vm_id} uploadée sur DriveHQ")
            return True
            
        except Exception as e:
            print(f"Erreur upload FTP: {e}")
            return False
    
    async def download_vm(self, vm_id: str, local_path: Path) -> bool:
        """Télécharger une VM depuis DriveHQ"""
        try:
            ftp = self.connect()
            
            vm_remote_dir = f"{self.config.FTP_VM_STORAGE}/{vm_id}"
            
            # Récupérer la liste des fichiers
            files = []
            ftp.cwd(vm_remote_dir)
            ftp.retrlines('LIST', files.append)
            
            # Télécharger récursivement
            self._download_directory(ftp, vm_remote_dir, local_path)
            
            ftp.quit()
            print(f"VM {vm_id} téléchargée depuis DriveHQ")
            return True
            
        except Exception as e:
            print(f"Erreur download FTP: {e}")
            return False
    
    def _download_directory(self, ftp, remote_dir, local_dir):
        """Télécharger récursivement un répertoire"""
        try:
            os.makedirs(local_dir, exist_ok=True)
            
            items = []
            ftp.cwd(remote_dir)
            ftp.retrlines('LIST', items.append)
            
            for item in items:
                parts = item.split()
                if len(parts) < 9:
                    continue
                
                name = ' '.join(parts[8:])
                if name in ['.', '..']:
                    continue
                
                remote_path = f"{remote_dir}/{name}"
                local_path = os.path.join(local_dir, name)
                
                if item.startswith('d'):  # C'est un répertoire
                    self._download_directory(ftp, remote_path, local_path)
                else:  # C'est un fichier
                    with open(local_path, 'wb') as f:
                        ftp.retrbinary(f'RETR {name}', f.write)
                        
        except Exception as e:
            print(f"Erreur téléchargement répertoire: {e}")
    
    async def list_vms(self) -> List[str]:
        """Lister les VMs disponibles sur DriveHQ"""
        try:
            ftp = self.connect()
            ftp.cwd(self.config.FTP_VM_STORAGE)
            
            items = []
            ftp.retrlines('LIST', items.append)
            
            vms = []
            for item in items:
                parts = item.split()
                if len(parts) >= 9 and item.startswith('d'):
                    name = ' '.join(parts[8:])
                    if name not in ['.', '..']:
                        vms.append(name)
            
            ftp.quit()
            return vms
            
        except Exception as e:
            print(f"Erreur liste FTP: {e}")
            return []
    
    async def delete_vm(self, vm_id: str) -> bool:
        """Supprimer une VM de DriveHQ"""
        try:
            ftp = self.connect()
            self._delete_recursive(ftp, f"{self.config.FTP_VM_STORAGE}/{vm_id}")
            ftp.quit()
            print(f"VM {vm_id} supprimée de DriveHQ")
            return True
        except Exception as e:
            print(f"Erreur suppression FTP: {e}")
            return False
    
    def _delete_recursive(self, ftp, path):
        """Supprimer récursivement un répertoire FTP"""
        try:
            items = []
            ftp.cwd(path)
            ftp.retrlines('LIST', items.append)
            
            for item in items:
                parts = item.split()
                if len(parts) < 9:
                    continue
                
                name = ' '.join(parts[8:])
                if name in ['.', '..']:
                    continue
                
                full_path = f"{path}/{name}"
                
                if item.startswith('d'):  # Répertoire
                    self._delete_recursive(ftp, full_path)
                else:  # Fichier
                    ftp.delete(full_path)
            
            ftp.cwd('..')
            ftp.rmd(path)
            
        except Exception as e:
            print(f"Erreur suppression récursive: {e}")

# Initialiser le gestionnaire FTP
ftp_manager = FTPManager()

# === APPLICATION ===
app = FastAPI(title=Config.APP_NAME, version=Config.APP_VERSION)

# Middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Managers
vm_manager = VMManager()
cloudinary_manager = CloudinaryManager()
security = HTTPBearer()

# === DEPENDANCES ===
async def get_current_user(token: HTTPAuthorizationCredentials = Depends(security)):
    """Récupérer l'utilisateur depuis le token JWT"""
    try:
        payload = SecurityUtils.verify_jwt_token(token.credentials)
        username: str = payload.get("sub")
        user_id: int = payload.get("user_id")
        role: str = payload.get("role")
        
        if username is None or user_id is None:
            raise HTTPException(
                status_code=401,
                detail="Token invalide",
                headers={"WWW-Authenticate": "Bearer"},
            )
        
        return {"username": username, "id": user_id, "role": role}
    except HTTPException:
        raise
    except Exception:
        raise HTTPException(
            status_code=401,
            detail="Erreur d'authentification",
            headers={"WWW-Authenticate": "Bearer"},
        )

async def require_auth(user: Dict = Depends(get_current_user)):
    """Vérifier que l'utilisateur est authentifié"""
    if not user:
        raise HTTPException(status_code=401, detail="Authentification requise")
    return user

# === ROUTES API ===
@app.get("/")
async def root():
    """Page d'accueil API"""
    return {
        "app": Config.APP_NAME,
        "version": Config.APP_VERSION,
        "status": "online",
        "features": ["vms", "files", "commands", "cloudinary", "ftp", "auth"],
        "endpoints": {
            "auth": {
                "register": "POST /api/auth/register",
                "login": "POST /api/auth/login",
                "me": "GET /api/auth/me"
            },
            "vms": {
                "create": "POST /api/vms",
                "list": "GET /api/vms",
                "detail": "GET /api/vms/{vm_id}",
                "update": "PUT /api/vms/{vm_id}",
                "delete": "DELETE /api/vms/{vm_id}",
                "download": "GET /api/vms/{vm_id}/download",
                "rate": "POST /api/vms/{vm_id}/rate",
                "favorite": "POST /api/vms/{vm_id}/favorite",
                "execute": "POST /api/vms/{vm_id}/execute",
                "status": "GET /api/vms/{vm_id}/status",
                "commands": "GET /api/vms/{vm_id}/commands"
            },
            "files": {
                "upload": "POST /api/vms/{vm_id}/files",
                "list": "GET /api/vms/{vm_id}/files",
                "get": "GET /api/vms/{vm_id}/files/{file_id}",
                "update": "PUT /api/vms/{vm_id}/files/{file_id}",
                "delete": "DELETE /api/vms/{vm_id}/files/{file_id}",
                "upload_raw": "POST /api/vms/{vm_id}/files/upload"
            },
            "cloudinary": {
                "upload": "POST /api/cloudinary/upload",
                "upload_code": "POST /api/cloudinary/upload/code"
            },
            "commands": {
                "execute": "POST /api/vms/{vm_id}/execute",
                "predefined": "POST /api/vms/{vm_id}/execute/predefined",
                "history": "GET /api/vms/{vm_id}/commands"
            },
            "comments": {
                "create": "POST /api/comments",
                "list": "GET /api/vms/{vm_id}/comments",
                "like": "POST /api/comments/{comment_id}/like"
            },
            "marketplace": {
                "publications": "GET /api/marketplace",
                "publication_detail": "GET /api/publications/{publication_id}"
            }
        }
    }

# === AUTHENTIFICATION ===
@app.post("/api/auth/register", response_model=Token)
async def register(user_data: UserCreate):
    """Enregistrement d'un nouvel utilisateur"""
    try:
        async with Database.pool.acquire() as conn:
            existing = await conn.fetchval(
                "SELECT COUNT(*) FROM users WHERE username = $1",
                user_data.username
            )
            
            if existing:
                raise HTTPException(status_code=400, detail="Nom d'utilisateur déjà pris")
            
            password_hash = SecurityUtils.hash_password(user_data.password)
            api_key = f"glv_{secrets.token_urlsafe(16)}"
            
            user = await conn.fetchrow("""
                INSERT INTO users (username, password_hash, api_key)
                VALUES ($1, $2, $3)
                RETURNING id, username, role
            """, user_data.username, password_hash, api_key)
            
            token = SecurityUtils.create_jwt_token(
                username=user["username"],
                user_id=user["id"],
                role=user["role"]
            )
            
            return Token(
                access_token=token,
                token_type="bearer",
                user_id=user["id"],
                username=user["username"],
                role=user["role"]
            )
            
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/api/auth/login", response_model=Token)
async def login(user_data: UserLogin):
    """Connexion utilisateur"""
    try:
        async with Database.pool.acquire() as conn:
            user = await conn.fetchrow("""
                SELECT id, username, password_hash, role
                FROM users 
                WHERE username = $1
            """, user_data.username)
            
            if not user or not SecurityUtils.verify_password(user_data.password, user["password_hash"]):
                raise HTTPException(status_code=401, detail="Identifiants incorrects")
            
            await conn.execute("""
                UPDATE users SET last_login = CURRENT_TIMESTAMP 
                WHERE id = $1
            """, user["id"])
            
            token = SecurityUtils.create_jwt_token(
                username=user["username"],
                user_id=user["id"],
                role=user["role"]
            )
            
            return Token(
                access_token=token,
                token_type="bearer",
                user_id=user["id"],
                username=user["username"],
                role=user["role"]
            )
            
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/auth/me")
async def get_current_user_info(user: Dict = Depends(require_auth)):
    """Récupérer les informations de l'utilisateur connecté"""
    try:
        async with Database.pool.acquire() as conn:
            user_info = await conn.fetchrow("""
                SELECT id, username, avatar_url, bio, role, reputation, 
                       created_at, last_login, stats
                FROM users 
                WHERE id = $1
            """, user["id"])
            
            return dict(user_info)
            
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

# === VMS ===
@app.post("/api/vms")
async def create_vm(vm_data: VMCreate, user: Dict = Depends(require_auth)):
    """Créer une nouvelle VM"""
    try:
        async with Database.pool.acquire() as conn:
            user_vm_count = await conn.fetchval(
                "SELECT COUNT(*) FROM vms WHERE owner_id = $1",
                user["id"]
            )
            
            if user_vm_count >= Config.MAX_VMS_PER_USER:
                raise HTTPException(
                    status_code=400,
                    detail=f"Limite atteinte: {Config.MAX_VMS_PER_USER} VMs maximum"
                )
            
            vm_id = f"golv_{uuid.uuid4().hex[:8]}"
            
            vm_result = await vm_manager.create_vm(vm_id, vm_data.vm_type, vm_data.version, user["id"])
            
            if not vm_result.get("success"):
                raise HTTPException(status_code=500, detail=vm_result.get("error", "Erreur création VM"))
            
            tag_list = vm_data.tags or []
            if not tag_list and vm_data.vm_type in Config.VM_TYPES:
                tag_list = Config.VM_TYPES[vm_data.vm_type].get("default_tags", [])
            
            await conn.execute("""
                INSERT INTO vms (
                    id, name, description, vm_type, version, owner_id,
                    is_public, is_published, downloads_count, views_count,
                    config, tags, metadata
                ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, 0, 0, $9, $10, $11)
            """, 
                vm_id, vm_data.name, vm_data.description, vm_data.vm_type, vm_data.version, user["id"],
                vm_data.is_public, False, 
                json.dumps(vm_result.get("config", {})),
                json.dumps(tag_list),
                json.dumps({"created_via": "api"})
            )
            
            await conn.execute("""
                UPDATE users SET stats = jsonb_set(
                    stats,
                    '{vms_created}',
                    to_jsonb((stats->>'vms_created')::int + 1)
                ) WHERE id = $1
            """, user["id"])
            
            return {
                "success": True,
                "vm_id": vm_id,
                "message": "VM créée avec succès",
                "data": vm_result
            }
            
    except HTTPException:
        raise
    except Exception as e:
        print(f"Erreur création VM: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/vms")
async def list_vms(
    user: Optional[Dict] = Depends(get_current_user),
    public_only: bool = Query(True, description="Afficher seulement les VMs publiques"),
    page: int = Query(1, ge=1),
    limit: int = Query(20, ge=1, le=100)
):
    """Lister les VMs"""
    try:
        async with Database.pool.acquire() as conn:
            offset = (page - 1) * limit
            
            if public_only or not user:
                query = """
                    SELECT v.*, u.username as owner_name,
                           COUNT(DISTINCT d.id) as total_downloads,
                           COUNT(DISTINCT c.id) as total_comments,
                           EXISTS(SELECT 1 FROM favorites f WHERE f.vm_id = v.id AND f.user_id = $1) as is_favorite
                    FROM vms v
                    JOIN users u ON v.owner_id = u.id
                    LEFT JOIN downloads d ON v.id = d.vm_id
                    LEFT JOIN comments c ON v.id = c.vm_id
                    LEFT JOIN favorites f ON v.id = f.vm_id AND f.user_id = $1
                    WHERE v.is_public = true
                    GROUP BY v.id, u.username
                    ORDER BY v.created_at DESC
                    LIMIT $2 OFFSET $3
                """
                params = [user["id"] if user else 0, limit, offset]
            else:
                query = """
                    SELECT v.*, u.username as owner_name,
                           COUNT(DISTINCT d.id) as total_downloads,
                           COUNT(DISTINCT c.id) as total_comments,
                           EXISTS(SELECT 1 FROM favorites f WHERE f.vm_id = v.id AND f.user_id = $1) as is_favorite
                    FROM vms v
                    JOIN users u ON v.owner_id = u.id
                    LEFT JOIN downloads d ON v.id = d.vm_id
                    LEFT JOIN comments c ON v.id = c.vm_id
                    LEFT JOIN favorites f ON v.id = f.vm_id AND f.user_id = $1
                    WHERE v.owner_id = $1 OR v.is_public = true
                    GROUP BY v.id, u.username
                    ORDER BY v.created_at DESC
                    LIMIT $2 OFFSET $3
                """
                params = [user["id"], limit, offset]
            
            vms = await conn.fetch(query, *params)
            
            # Compter total
            if public_only or not user:
                count_query = "SELECT COUNT(*) FROM vms WHERE is_public = true"
                total = await conn.fetchval(count_query)
            else:
                count_query = "SELECT COUNT(*) FROM vms WHERE owner_id = $1 OR is_public = true"
                total = await conn.fetchval(count_query, user["id"])
            
            return {
                "success": True,
                "page": page,
                "limit": limit,
                "total": total,
                "total_pages": (total + limit - 1) // limit,
                "data": [dict(vm) for vm in vms]
            }
            
    except Exception as e:
        print(f"Erreur liste VMs: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/vms/{vm_id}")
async def get_vm(vm_id: str, user: Optional[Dict] = Depends(get_current_user)):
    """Récupérer les détails d'une VM"""
    try:
        async with Database.pool.acquire() as conn:
            # Incrémenter les vues si l'utilisateur est authentifié
            if user:
                await conn.execute("""
                    INSERT INTO vm_views (vm_id, user_id)
                    VALUES ($1, $2)
                    ON CONFLICT (vm_id, user_id) DO UPDATE SET viewed_at = CURRENT_TIMESTAMP
                """, vm_id, user["id"])
            
            query = """
                SELECT v.*, u.username as owner_name, u.avatar_url as owner_avatar,
                       EXISTS(SELECT 1 FROM favorites f WHERE f.vm_id = v.id AND f.user_id = $1) as is_favorite,
                       COUNT(DISTINCT d.id) as total_downloads,
                       COUNT(DISTINCT c.id) as total_comments
                FROM vms v
                JOIN users u ON v.owner_id = u.id
                LEFT JOIN downloads d ON v.id = d.vm_id
                LEFT JOIN comments c ON v.id = c.vm_id
                WHERE v.id = $2
                GROUP BY v.id, u.id
            """
            
            vm = await conn.fetchrow(query, user["id"] if user else 0, vm_id)
            
            if not vm:
                raise HTTPException(status_code=404, detail="VM non trouvée")
            
            vm_dict = dict(vm)
            
            # Vérifier l'accès
            if not vm_dict["is_public"] and (not user or vm_dict["owner_id"] != user["id"]):
                raise HTTPException(status_code=403, detail="Accès non autorisé")
            
            # Récupérer les fichiers associés
            files = await conn.fetch("""
                SELECT * FROM code_files 
                WHERE vm_id = $1 
                ORDER BY file_path
            """, vm_id)
            
            vm_dict["files"] = [dict(file) for file in files]
            
            return {
                "success": True,
                "data": vm_dict
            }
            
    except HTTPException:
        raise
    except Exception as e:
        print(f"Erreur détail VM: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.put("/api/vms/{vm_id}")
async def update_vm(vm_id: str, vm_data: VMUpdate, user: Dict = Depends(require_auth)):
    """Mettre à jour une VM"""
    try:
        async with Database.pool.acquire() as conn:
            # Vérifier la propriété
            vm = await conn.fetchrow("""
                SELECT owner_id FROM vms WHERE id = $1
            """, vm_id)
            
            if not vm:
                raise HTTPException(status_code=404, detail="VM non trouvée")
            
            if vm["owner_id"] != user["id"] and user["role"] != "admin":
                raise HTTPException(status_code=403, detail="Accès non autorisé")
            
            # Construire la requête de mise à jour
            updates = []
            params = []
            param_count = 1
            
            if vm_data.name is not None:
                updates.append(f"name = ${param_count}")
                params.append(vm_data.name)
                param_count += 1
            
            if vm_data.description is not None:
                updates.append(f"description = ${param_count}")
                params.append(vm_data.description)
                param_count += 1
            
            if vm_data.is_public is not None:
                updates.append(f"is_public = ${param_count}")
                params.append(vm_data.is_public)
                param_count += 1
            
            if vm_data.tags is not None:
                updates.append(f"tags = ${param_count}")
                params.append(json.dumps(vm_data.tags))
                param_count += 1
            
            if not updates:
                raise HTTPException(status_code=400, detail="Aucune donnée à mettre à jour")
            
            updates.append(f"updated_at = CURRENT_TIMESTAMP")
            
            query = f"""
                UPDATE vms 
                SET {', '.join(updates)}
                WHERE id = ${param_count}
                RETURNING *
            """
            params.append(vm_id)
            
            updated_vm = await conn.fetchrow(query, *params)
            
            return {
                "success": True,
                "message": "VM mise à jour avec succès",
                "data": dict(updated_vm)
            }
            
    except HTTPException:
        raise
    except Exception as e:
        print(f"Erreur mise à jour VM: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.delete("/api/vms/{vm_id}")
async def delete_vm(vm_id: str, user: Dict = Depends(require_auth)):
    """Supprimer une VM"""
    try:
        async with Database.pool.acquire() as conn:
            # Vérifier la propriété
            vm = await conn.fetchrow("""
                SELECT owner_id FROM vms WHERE id = $1
            """, vm_id)
            
            if not vm:
                raise HTTPException(status_code=404, detail="VM non trouvée")
            
            if vm["owner_id"] != user["id"] and user["role"] != "admin":
                raise HTTPException(status_code=403, detail="Accès non autorisé")
            
            # Supprimer les fichiers Cloudinary associés
            files = await conn.fetch("""
                SELECT cloudinary_public_id FROM code_files 
                WHERE vm_id = $1 AND cloudinary_public_id IS NOT NULL
            """, vm_id)
            
            for file in files:
                if file["cloudinary_public_id"]:
                    await cloudinary_manager.delete_file(file["cloudinary_public_id"])
            
            # Supprimer la VM
            await conn.execute("DELETE FROM vms WHERE id = $1", vm_id)
            
            # Supprimer le dossier local
            vm_path = Config.VM_STORAGE / vm_id
            if vm_path.exists():
                shutil.rmtree(vm_path, ignore_errors=True)
            
            return {
                "success": True,
                "message": "VM supprimée avec succès"
            }
            
    except HTTPException:
        raise
    except Exception as e:
        print(f"Erreur suppression VM: {e}")
        raise HTTPException(status_code=500, detail=str(e))

# === NOUVELLES ROUTES POUR EXÉCUTION DE COMMANDES ===
@app.post("/api/vms/{vm_id}/execute")
async def execute_vm_command(
    vm_id: str,
    command_data: VMCommand,
    user: Dict = Depends(require_auth)
):
    """Exécuter une commande dans une VM"""
    try:
        async with Database.pool.acquire() as conn:
            # Vérifier la propriété
            vm = await conn.fetchrow("""
                SELECT owner_id, is_public FROM vms WHERE id = $1
            """, vm_id)
            
            if not vm:
                raise HTTPException(status_code=404, detail="VM non trouvée")
            
            if vm["owner_id"] != user["id"] and not vm["is_public"] and user["role"] != "admin":
                raise HTTPException(status_code=403, detail="Accès non autorisé")
            
            # Exécuter la commande
            result = await vm_manager.execute_command(vm_id, command_data, user["id"])
            
            # Sauvegarder dans la base de données
            if result.get("success") is not None:
                await conn.execute("""
                    INSERT INTO vm_commands 
                    (vm_id, user_id, command, return_code, stdout, stderr, duration_ms, status)
                    VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
                """, 
                    vm_id, user["id"], command_data.command,
                    result.get("return_code"),
                    result.get("stdout", "")[:1000],  # Limiter la taille
                    result.get("stderr", "")[:1000],
                    result.get("duration_ms", 0),
                    "completed" if result.get("success") else "failed"
                )
            
            # Mettre à jour les stats de la VM
            if result.get("success"):
                await conn.execute("""
                    UPDATE vms SET config = jsonb_set(
                        config,
                        '{stats,commands_executed}',
                        to_jsonb(((config->'stats'->>'commands_executed')::int + 1))
                    ) WHERE id = $1
                """, vm_id)
            
            return {
                "success": result.get("success", False),
                "vm_id": vm_id,
                "user_id": user["id"],
                "data": result
            }
            
    except HTTPException:
        raise
    except Exception as e:
        print(f"Erreur exécution commande: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/vms/{vm_id}/commands")
async def get_vm_commands(
    vm_id: str,
    limit: int = Query(10, ge=1, le=100),
    user: Dict = Depends(require_auth)
):
    """Récupérer l'historique des commandes d'une VM"""
    try:
        async with Database.pool.acquire() as conn:
            # Vérifier la propriété
            vm = await conn.fetchrow("""
                SELECT owner_id, is_public FROM vms WHERE id = $1
            """, vm_id)
            
            if not vm:
                raise HTTPException(status_code=404, detail="VM non trouvée")
            
            if vm["owner_id"] != user["id"] and not vm["is_public"] and user["role"] != "admin":
                raise HTTPException(status_code=403, detail="Accès non autorisé")
            
            # Récupérer l'historique depuis la base
            commands = await conn.fetch("""
                SELECT c.*, u.username 
                FROM vm_commands c
                JOIN users u ON c.user_id = u.id
                WHERE c.vm_id = $1
                ORDER BY c.executed_at DESC
                LIMIT $2
            """, vm_id, limit)
            
            # Récupérer aussi l'historique local (mémoire)
            local_history = await vm_manager.get_command_history(vm_id, limit)
            
            return {
                "success": True,
                "vm_id": vm_id,
                "database_history": [dict(cmd) for cmd in commands],
                "local_history": local_history,
                "total": len(commands) + len(local_history)
            }
            
    except HTTPException:
        raise
    except Exception as e:
        print(f"Erreur récupération historique: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/vms/{vm_id}/status")
async def get_vm_status(vm_id: str, user: Dict = Depends(require_auth)):
    """Récupérer le statut d'une VM"""
    try:
        async with Database.pool.acquire() as conn:
            # Vérifier la propriété
            vm = await conn.fetchrow("""
                SELECT owner_id, is_public FROM vms WHERE id = $1
            """, vm_id)
            
            if not vm:
                raise HTTPException(status_code=404, detail="VM non trouvée")
            
            if vm["owner_id"] != user["id"] and not vm["is_public"] and user["role"] != "admin":
                raise HTTPException(status_code=403, detail="Accès non autorisé")
            
            # Récupérer le statut du manager
            status_info = await vm_manager.get_vm_status(vm_id)
            
            # Récupérer les infos de la base
            vm_info = await conn.fetchrow("""
                SELECT downloads_count, views_count, average_rating, created_at
                FROM vms WHERE id = $1
            """, vm_id)
            
            return {
                "success": True,
                "vm_id": vm_id,
                "status": status_info,
                "stats": dict(vm_info) if vm_info else {}
            }
            
    except HTTPException:
        raise
    except Exception as e:
        print(f"Erreur statut VM: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/api/vms/{vm_id}/execute/predefined")
async def execute_predefined_command(
    vm_id: str,
    command_type: str = Body(..., embed=True),
    user: Dict = Depends(require_auth)
):
    """Exécuter une commande pré-définie"""
    
    predefined_commands = {
        "status": {
            "command": "echo '=== Status VM ===' && pwd && ls -la && python3 --version && echo 'Uptime:' && uptime 2>/dev/null || echo 'Uptime non disponible'",
            "description": "Statut de la VM",
            "timeout": 15
        },
        "python_test": {
            "command": "python3 -c \"print('Hello from Python!'); import sys; print(f'Version: {sys.version}'); print(f'Platform: {sys.platform}')\"",
            "description": "Test Python",
            "timeout": 10
        },
        "disk_usage": {
            "command": "echo '=== Disk Usage ===' && df -h . && echo '--- Directory Size ---' && du -sh . 2>/dev/null || echo 'du non disponible'",
            "description": "Utilisation disque",
            "timeout": 15
        },
        "list_py_files": {
            "command": "find . -type f -name '*.py' | head -20",
            "description": "Lister fichiers Python",
            "timeout": 10
        },
        "create_test_file": {
            "command": "echo '# File created at $(date)' > test_$(date +%s).txt && echo 'Fichier créé:' && ls -la test_*.txt",
            "description": "Créer fichier test",
            "timeout": 10
        },
        "network_info": {
            "command": "echo '=== Network Info ===' && hostname && echo 'IP:' && (hostname -I 2>/dev/null || echo '127.0.0.1')",
            "description": "Informations réseau",
            "timeout": 10
        }
    }
    
    if command_type not in predefined_commands:
        raise HTTPException(status_code=400, detail="Commande pré-définie non reconnue")
    
    cmd_info = predefined_commands[command_type]
    cmd_data = VMCommand(
        command=cmd_info["command"],
        timeout=cmd_info["timeout"],
        working_dir="."
    )
    
    # Réutiliser la route d'exécution
    return await execute_vm_command(vm_id, cmd_data, user)

# === FICHIERS CLOUDINARY ===
@app.post("/api/cloudinary/upload")
async def upload_to_cloudinary(
    file: UploadFile = File(...),
    folder: str = Form("golv_vms"),
    user: Dict = Depends(require_auth)
):
    """Uploader un fichier sur Cloudinary"""
    try:
        upload_result = await cloudinary_manager.upload_file(file, folder)
        
        return {
            "success": True,
            "message": "Fichier uploadé avec succès",
            "data": upload_result
        }
        
    except HTTPException:
        raise
    except Exception as e:
        print(f"Erreur upload Cloudinary: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/api/cloudinary/upload/code")
async def upload_code_to_cloudinary(
    content: str = Form(...),
    filename: str = Form(...),
    folder: str = Form("golv_code"),
    user: Dict = Depends(require_auth)
):
    """Uploader du code sur Cloudinary"""
    try:
        upload_result = await cloudinary_manager.upload_code_content(content, filename, folder)
        
        return {
            "success": True,
            "message": "Code uploadé avec succès",
            "data": upload_result
        }
        
    except HTTPException:
        raise
    except Exception as e:
        print(f"Erreur upload code Cloudinary: {e}")
        raise HTTPException(status_code=500, detail=str(e))

# === FICHIERS DE CODE ===
@app.post("/api/vms/{vm_id}/files")
async def create_code_file(
    vm_id: str,
    file_data: CodeFileCreate,
    user: Dict = Depends(require_auth)
):
    """Créer un fichier de code pour une VM"""
    try:
        async with Database.pool.acquire() as conn:
            # Vérifier la propriété de la VM
            vm = await conn.fetchrow("""
                SELECT owner_id FROM vms WHERE id = $1
            """, vm_id)
            
            if not vm:
                raise HTTPException(status_code=404, detail="VM non trouvée")
            
            if vm["owner_id"] != user["id"]:
                raise HTTPException(status_code=403, detail="Accès non autorisé")
            
            # Uploader sur Cloudinary
            upload_result = await cloudinary_manager.upload_code_content(
                file_data.content,
                f"{vm_id}/{file_data.file_path}",
                "golv_vm_code"
            )
            
            if not upload_result.get("success"):
                raise HTTPException(status_code=500, detail="Erreur upload Cloudinary")
            
            # Sauvegarder en base
            file_name = os.path.basename(file_data.file_path)
            
            code_file = await conn.fetchrow("""
                INSERT INTO code_files (
                    vm_id, user_id, file_path, file_name, 
                    content_type, cloudinary_url, cloudinary_public_id,
                    language, content, file_size
                ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
                RETURNING *
            """, 
                vm_id, user["id"], file_data.file_path, file_name,
                "text/plain", upload_result.get("secure_url"), upload_result.get("public_id"),
                file_data.language or "plaintext", file_data.content, len(file_data.content)
            )
            
            return {
                "success": True,
                "message": "Fichier créé avec succès",
                "data": dict(code_file)
            }
            
    except HTTPException:
        raise
    except Exception as e:
        print(f"Erreur création fichier: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/api/vms/{vm_id}/files/upload")
async def upload_file_to_vm(
    vm_id: str,
    file: UploadFile = File(...),
    file_path: str = Form(...),
    language: str = Form("plaintext"),
    user: Dict = Depends(require_auth)
):
    """Uploader un fichier pour une VM"""
    try:
        async with Database.pool.acquire() as conn:
            # Vérifier la propriété de la VM
            vm = await conn.fetchrow("""
                SELECT owner_id FROM vms WHERE id = $1
            """, vm_id)
            
            if not vm:
                raise HTTPException(status_code=404, detail="VM non trouvée")
            
            if vm["owner_id"] != user["id"]:
                raise HTTPException(status_code=403, detail="Accès non autorisé")
            
            # Lire le contenu
            content_bytes = await file.read()
            content = content_bytes.decode('utf-8')
            
            # Uploader sur Cloudinary
            upload_result = await cloudinary_manager.upload_code_content(
                content,
                f"{vm_id}/{file_path}",
                "golv_vm_files"
            )
            
            if not upload_result.get("success"):
                raise HTTPException(status_code=500, detail="Erreur upload Cloudinary")
            
            # Sauvegarder en base
            file_name = os.path.basename(file_path)
            
            code_file = await conn.fetchrow("""
                INSERT INTO code_files (
                    vm_id, user_id, file_path, file_name, 
                    content_type, cloudinary_url, cloudinary_public_id,
                    language, content, file_size
                ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
                RETURNING *
            """, 
                vm_id, user["id"], file_path, file_name,
                file.content_type or "text/plain", 
                upload_result.get("secure_url"), 
                upload_result.get("public_id"),
                language, content, len(content_bytes)
            )
            
            return {
                "success": True,
                "message": "Fichier uploadé avec succès",
                "data": dict(code_file)
            }
            
    except HTTPException:
        raise
    except UnicodeDecodeError:
        raise HTTPException(status_code=400, detail="Fichier non texte - encodage UTF-8 requis")
    except Exception as e:
        print(f"Erreur upload fichier: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/vms/{vm_id}/files")
async def list_vm_files(
    vm_id: str,
    user: Optional[Dict] = Depends(get_current_user)
):
    """Lister les fichiers d'une VM"""
    try:
        async with Database.pool.acquire() as conn:
            # Vérifier l'accès à la VM
            vm = await conn.fetchrow("""
                SELECT is_public, owner_id FROM vms WHERE id = $1
            """, vm_id)
            
            if not vm:
                raise HTTPException(status_code=404, detail="VM non trouvée")
            
            if not vm["is_public"] and (not user or vm["owner_id"] != user["id"]):
                raise HTTPException(status_code=403, detail="Accès non autorisé")
            
            files = await conn.fetch("""
                SELECT * FROM code_files 
                WHERE vm_id = $1 
                ORDER BY file_path
            """, vm_id)
            
            return {
                "success": True,
                "data": [dict(file) for file in files]
            }
            
    except HTTPException:
        raise
    except Exception as e:
        print(f"Erreur liste fichiers: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/vms/{vm_id}/files/{file_id}")
async def get_vm_file(
    vm_id: str,
    file_id: int,
    user: Optional[Dict] = Depends(get_current_user)
):
    """Récupérer un fichier spécifique d'une VM"""
    try:
        async with Database.pool.acquire() as conn:
            # Vérifier l'accès à la VM
            vm = await conn.fetchrow("""
                SELECT is_public, owner_id FROM vms WHERE id = $1
            """, vm_id)
            
            if not vm:
                raise HTTPException(status_code=404, detail="VM non trouvée")
            
            if not vm["is_public"] and (not user or vm["owner_id"] != user["id"]):
                raise HTTPException(status_code=403, detail="Accès non autorisé")
            
            file = await conn.fetchrow("""
                SELECT * FROM code_files 
                WHERE id = $1 AND vm_id = $2
            """, file_id, vm_id)
            
            if not file:
                raise HTTPException(status_code=404, detail="Fichier non trouvé")
            
            return {
                "success": True,
                "data": dict(file)
            }
            
    except HTTPException:
        raise
    except Exception as e:
        print(f"Erreur récupération fichier: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.put("/api/vms/{vm_id}/files/{file_id}")
async def update_vm_file(
    vm_id: str,
    file_id: int,
    file_data: CodeFileUpdate,
    user: Dict = Depends(require_auth)
):
    """Mettre à jour un fichier de code"""
    try:
        async with Database.pool.acquire() as conn:
            # Vérifier la propriété de la VM et du fichier
            file = await conn.fetchrow("""
                SELECT cf.*, v.owner_id 
                FROM code_files cf
                JOIN vms v ON cf.vm_id = v.id
                WHERE cf.id = $1 AND cf.vm_id = $2
            """, file_id, vm_id)
            
            if not file:
                raise HTTPException(status_code=404, detail="Fichier non trouvé")
            
            if file["owner_id"] != user["id"]:
                raise HTTPException(status_code=403, detail="Accès non autorisé")
            
            # Mettre à jour sur Cloudinary si public_id existe
            if file["cloudinary_public_id"]:
                # Pour Cloudinary, on doit re-uploader le fichier
                upload_result = await cloudinary_manager.upload_code_content(
                    file_data.content,
                    file["file_path"],
                    "golv_vm_code"
                )
                
                if not upload_result.get("success"):
                    raise HTTPException(status_code=500, detail="Erreur upload Cloudinary")
                
                cloudinary_url = upload_result.get("secure_url")
                cloudinary_public_id = upload_result.get("public_id")
            else:
                cloudinary_url = file["cloudinary_url"]
                cloudinary_public_id = file["cloudinary_public_id"]
            
            # Mettre à jour en base
            updated_file = await conn.fetchrow("""
                UPDATE code_files 
                SET content = $1, 
                    cloudinary_url = $2,
                    cloudinary_public_id = $3,
                    file_size = $4,
                    updated_at = CURRENT_TIMESTAMP
                WHERE id = $5
                RETURNING *
            """, 
                file_data.content,
                cloudinary_url,
                cloudinary_public_id,
                len(file_data.content),
                file_id
            )
            
            return {
                "success": True,
                "message": "Fichier mis à jour avec succès",
                "data": dict(updated_file)
            }
            
    except HTTPException:
        raise
    except Exception as e:
        print(f"Erreur mise à jour fichier: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.delete("/api/vms/{vm_id}/files/{file_id}")
async def delete_vm_file(
    vm_id: str,
    file_id: int,
    user: Dict = Depends(require_auth)
):
    """Supprimer un fichier de code"""
    try:
        async with Database.pool.acquire() as conn:
            # Vérifier la propriété
            file = await conn.fetchrow("""
                SELECT cf.*, v.owner_id 
                FROM code_files cf
                JOIN vms v ON cf.vm_id = v.id
                WHERE cf.id = $1 AND cf.vm_id = $2
            """, file_id, vm_id)
            
            if not file:
                raise HTTPException(status_code=404, detail="Fichier non trouvé")
            
            if file["owner_id"] != user["id"]:
                raise HTTPException(status_code=403, detail="Accès non autorisé")
            
            # Supprimer de Cloudinary si public_id existe
            if file["cloudinary_public_id"]:
                await cloudinary_manager.delete_file(file["cloudinary_public_id"])
            
            # Supprimer de la base
            await conn.execute("DELETE FROM code_files WHERE id = $1", file_id)
            
            return {
                "success": True,
                "message": "Fichier supprimé avec succès"
            }
            
    except HTTPException:
        raise
    except Exception as e:
        print(f"Erreur suppression fichier: {e}")
        raise HTTPException(status_code=500, detail=str(e))

# === ROUTES FTP ===
@app.post("/api/vms/{vm_id}/backup")
async def backup_vm_to_ftp(vm_id: str, user: Dict = Depends(require_auth)):
    """Sauvegarder une VM sur DriveHQ FTP"""
    try:
        async with Database.pool.acquire() as conn:
            # Vérifier la propriété
            vm = await conn.fetchrow("""
                SELECT owner_id FROM vms WHERE id = $1
            """, vm_id)
            
            if not vm:
                raise HTTPException(status_code=404, detail="VM non trouvée")
            
            if vm["owner_id"] != user["id"] and user["role"] != "admin":
                raise HTTPException(status_code=403, detail="Accès non autorisé")
            
            vm_path = Config.VM_STORAGE / vm_id
            if not vm_path.exists():
                raise HTTPException(status_code=404, detail="Dossier VM local non trouvé")
            
            success = await ftp_manager.upload_vm(vm_id, vm_path)
            
            if success:
                return {
                    "success": True,
                    "message": f"VM {vm_id} sauvegardée sur DriveHQ",
                    "data": {
                        "vm_id": vm_id,
                        "backup_location": f"ftp://{FTPConfig.DRIVEHQ_HOST}{FTPConfig.FTP_VM_STORAGE}/{vm_id}"
                    }
                }
            else:
                raise HTTPException(status_code=500, detail="Erreur lors de la sauvegarde FTP")
            
    except HTTPException:
        raise
    except Exception as e:
        print(f"Erreur sauvegarde FTP: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/ftp/vms")
async def list_ftp_vms(user: Dict = Depends(require_auth)):
    """Lister les VMs disponibles sur DriveHQ"""
    try:
        vms = await ftp_manager.list_vms()
        
        return {
            "success": True,
            "data": {
                "ftp_host": FTPConfig.DRIVEHQ_HOST,
                "username": FTPConfig.DRIVEHQ_USERNAME,
                "total_vms": len(vms),
                "vms": vms
            }
        }
        
    except Exception as e:
        print(f"Erreur liste FTP VMs: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/api/vms/{vm_id}/restore")
async def restore_vm_from_ftp(vm_id: str, user: Dict = Depends(require_auth)):
    """Restaurer une VM depuis DriveHQ"""
    try:
        async with Database.pool.acquire() as conn:
            # Vérifier si la VM existe en base
            vm = await conn.fetchrow("""
                SELECT owner_id FROM vms WHERE id = $1
            """, vm_id)
            
            if not vm:
                raise HTTPException(status_code=404, detail="VM non trouvée en base de données")
            
            if vm["owner_id"] != user["id"] and user["role"] != "admin":
                raise HTTPException(status_code=403, detail="Accès non autorisé")
            
            vm_path = Config.VM_STORAGE / vm_id
            
            # Restaurer depuis FTP
            success = await ftp_manager.download_vm(vm_id, vm_path)
            
            if success:
                return {
                    "success": True,
                    "message": f"VM {vm_id} restaurée depuis DriveHQ",
                    "data": {
                        "vm_id": vm_id,
                        "restored_to": str(vm_path)
                    }
                }
            else:
                raise HTTPException(status_code=500, detail="Erreur lors de la restauration FTP")
            
    except HTTPException:
        raise
    except Exception as e:
        print(f"Erreur restauration FTP: {e}")
        raise HTTPException(status_code=500, detail=str(e))

# === TÉLÉCHARGEMENT ===
@app.get("/api/vms/{vm_id}/download")
async def download_vm(vm_id: str, format: str = Query("tar"), user: Optional[Dict] = Depends(get_current_user)):
    """Télécharger une VM"""
    try:
        async with Database.pool.acquire() as conn:
            vm = await conn.fetchrow("""
                SELECT is_public, owner_id FROM vms WHERE id = $1
            """, vm_id)
            
            if not vm:
                raise HTTPException(status_code=404, detail="VM non trouvée")
            
            if not vm["is_public"] and (not user or vm["owner_id"] != user["id"]):
                raise HTTPException(status_code=403, detail="Accès non autorisé")
            
            export_file = await vm_manager.export_vm(vm_id, format)
            if not export_file or not export_file.exists():
                raise HTTPException(status_code=404, detail="VM non exportable")
            
            if user:
                await conn.execute("""
                    INSERT INTO downloads (vm_id, user_id, version, ip_address)
                    VALUES ($1, $2, $3, $4)
                """, vm_id, user["id"], "export", "api_download")
            
            await conn.execute("""
                UPDATE vms SET 
                    downloads_count = downloads_count + 1,
                    last_download = CURRENT_TIMESTAMP
                WHERE id = $1
            """, vm_id)
            
            if vm["owner_id"]:
                await conn.execute("""
                    UPDATE users SET stats = jsonb_set(
                        stats,
                        '{downloads_given}',
                        to_jsonb((stats->>'downloads_given')::int + 1)
                    ) WHERE id = $1
                """, vm["owner_id"])
            
            filename = f"{vm_id}.{format}" + (".gz" if format == "tar" else "")
            return FileResponse(
                export_file,
                media_type="application/octet-stream",
                filename=filename
            )
            
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

# === LIFECYCLE ===
@asynccontextmanager
async def lifespan(app: FastAPI):
    # Démarrage
    print(f"\n{'='*60}")
    print(f"{Config.APP_NAME} v{Config.APP_VERSION}")
    print(f"{'='*60}")
    
    # Vérifier Cloudinary
    try:
        print("Configuration Cloudinary...")
        print(f"Cloud Name: {Config.CLOUDINARY_CLOUD_NAME}")
        print("Cloudinary configuré avec succès")
    except Exception as e:
        print(f"Erreur configuration Cloudinary: {e}")
    
    # Connexion à la base de données
    try:
        await Database.connect()
        print("Base de données connectée")
    except Exception as e:
        print(f"Erreur connexion DB: {e}")
        print("L'application démarrera sans base de données")
    
    print(f"\nServeur démarré sur: http://{Config.HOST}:{Config.PORT}")
    print(f"Admin: username='admin', password='admin123'")
    print(f"{'='*60}\n")
    
    yield
    
    # Arrêt
    print("\nArrêt du serveur...")
    if Database.pool:
        await Database.pool.close()

# Ajouter le lifespan
app.router.lifespan_context = lifespan

# === DÉMARRAGE ===
if __name__ == "__main__":
    uvicorn.run(
        app,
        host=Config.HOST,
        port=Config.PORT,
        log_level="info"
                )